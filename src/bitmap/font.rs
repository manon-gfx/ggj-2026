pub struct Font {
    pub(crate) data: [[[bool; 5]; 5]; 256],
    pub(crate) translation: [usize; 256],
}

impl Font {
    pub fn new_default() -> Self {
        const CHARACTERS: [[u8; 5]; 58] = [
            [0b01110, 0b10001, 0b11111, 0b10001, 0b10001], // A
            [0b11110, 0b10001, 0b11110, 0b10001, 0b11110], // B
            [0b01111, 0b10000, 0b10000, 0b10000, 0b01111], // C
            [0b11110, 0b10001, 0b10001, 0b10001, 0b11110], // D
            [0b11111, 0b10000, 0b11110, 0b10000, 0b11111], // E
            [0b11111, 0b10000, 0b11110, 0b10000, 0b10000], // F
            [0b01111, 0b10000, 0b10111, 0b10001, 0b01110], // G
            [0b10001, 0b10001, 0b11111, 0b10001, 0b10001], // H
            [0b01110, 0b00100, 0b00100, 0b00100, 0b01110], // I
            [0b01110, 0b00100, 0b00100, 0b00100, 0b11000], // J
            [0b10010, 0b10100, 0b11000, 0b10100, 0b10010], // K
            [0b10000, 0b10000, 0b10000, 0b10000, 0b11111], // L
            [0b11010, 0b10101, 0b10101, 0b10001, 0b10001], // M
            [0b10001, 0b11001, 0b10101, 0b10011, 0b10001], // N
            [0b01110, 0b10001, 0b10001, 0b10001, 0b01110], // O
            [0b11110, 0b10001, 0b11110, 0b10000, 0b10000], // P
            [0b01110, 0b10001, 0b10001, 0b10011, 0b01111], // Q
            [0b11110, 0b10001, 0b11110, 0b10100, 0b10010], // R
            [0b01111, 0b10000, 0b01110, 0b00001, 0b11110], // S
            [0b11111, 0b00100, 0b00100, 0b00100, 0b00100], // T
            [0b10001, 0b10001, 0b10001, 0b10001, 0b01111], // U
            [0b10001, 0b10001, 0b01010, 0b01010, 0b00100], // V
            [0b10001, 0b10001, 0b10101, 0b10101, 0b01010], // W
            [0b10001, 0b01010, 0b00100, 0b01010, 0b10001], // X
            [0b10001, 0b10001, 0b01111, 0b00001, 0b01110], // Y
            [0b11111, 0b00010, 0b00100, 0b01000, 0b11111], // Z
            [0b01110, 0b10011, 0b10101, 0b11001, 0b01110], // 0
            [0b00100, 0b01100, 0b00100, 0b00100, 0b01110], // 1
            [0b01110, 0b10001, 0b00110, 0b01000, 0b11111], // 2
            [0b11110, 0b00001, 0b00110, 0b00001, 0b11110], // 3
            [0b10000, 0b10010, 0b11111, 0b00010, 0b00010], // 4
            [0b11111, 0b10000, 0b11110, 0b00001, 0b11110], // 5
            [0b01111, 0b10000, 0b11110, 0b10001, 0b01110], // 6
            [0b11111, 0b00001, 0b00010, 0b00100, 0b00100], // 7
            [0b01110, 0b10001, 0b01110, 0b10001, 0b01110], // 8
            [0b01110, 0b10001, 0b01111, 0b00001, 0b01110], // 9
            [0b00100, 0b00100, 0b00100, 0b00000, 0b00100], // !
            [0b01110, 0b00001, 0b00010, 0b00000, 0b00100], // ?
            [0b00000, 0b00000, 0b00100, 0b00000, 0b00100], // :
            [0b00000, 0b00000, 0b01110, 0b00000, 0b01110], // =
            [0b00000, 0b00000, 0b00000, 0b00010, 0b00100], // ,
            [0b00000, 0b00000, 0b00000, 0b00000, 0b00100], // .
            [0b00000, 0b00000, 0b01110, 0b00000, 0b00000], // _
            [0b00000, 0b00000, 0b00000, 0b00000, 0b01110], // _
            [0b00010, 0b00100, 0b00100, 0b00100, 0b00010], // (
            [0b00100, 0b00010, 0b00010, 0b00010, 0b00100], // )
            [0b00000, 0b00000, 0b00000, 0b00000, 0b00000], //
            [0b01010, 0b11111, 0b01010, 0b11111, 0b01010], // #
            [0b00100, 0b00100, 0b00000, 0b00000, 0b00000], // '
            [0b00100, 0b10101, 0b01110, 0b10101, 0b00100], // *
            [0b00001, 0b00010, 0b00100, 0b01000, 0b10000], // /
            [0b00010, 0b00100, 0b01000, 0b00100, 0b00010], // <
            [0b01000, 0b00100, 0b00010, 0b00100, 0b01000], // >
            [0b00100, 0b01010, 0b10001, 0b00000, 0b00000], // ^
            [0b00010, 0b00010, 0b00010, 0b00010, 0b00010], // |
            [0b00110, 0b00100, 0b00100, 0b00100, 0b00110], // [
            [0b01100, 0b00100, 0b00100, 0b00100, 0b01100], // ]
            [0b10010, 0b10010, 0b10010, 0b11110, 0b10000], // micro
        ];

        let mut data = [[[true; 5]; 5]; 256];
        for (i, character) in CHARACTERS.iter().enumerate() {
            #[allow(clippy::needless_range_loop)]
            for y in 0..5 {
                for x in 0..5 {
                    data[i][y][x] = ((character[y] >> (4 - x)) & 0x1) != 0;
                }
            }
        }

        let trans_str = "abcdefghijklmnopqrstuvwxyz0123456789!?:=,.-_() #'*/<>^|[]";

        let mut translation = [255; 256];
        translation[254] = CHARACTERS.len() - 1;
        for (i, c) in trans_str.chars().enumerate() {
            assert!(c.is_ascii());
            let idx = (c as usize) & 0xff;
            assert!(translation[idx] == 255);
            translation[idx] = i;
        }

        Self { data, translation }
    }
}
